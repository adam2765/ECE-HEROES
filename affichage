/* ================================
   ECE HEROES – Module Affichage
   - Plateau 25x45
   - Curseur + sélection
   - HUD complet: niveau, vies, score, coups, temps
   - Contrat: elimines / objectif + RESTE A ELIMINER (conforme)
   - Effacement intelligent du HUD (pas de résidus)
   ================================ */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <conio.h>
#include <time.h>

#define NB_LIG 25
#define NB_COL 45

#define NOIR 0
#define BLEU 9
#define VERT 10
#define ROUGE 12
#define MAGENTA 13
#define JAUNE 14
#define BLANC 15
#define GRIS 8

#define NB_ITEMS 5

#define KEY_UP     1001
#define KEY_DOWN   1002
#define KEY_LEFT   1003
#define KEY_RIGHT  1004

typedef struct {
    int grille[NB_LIG][NB_COL];
    int vies;
    int score;
    int coupsRestants;
    int niveauActuel;

    int tempsTotalSec;
    time_t startTime;

    // Contrat + progression
    int contrat[NB_ITEMS + 1];   // objectif à atteindre
    int elimines[NB_ITEMS + 1];  // combien éliminés

    int cursorX;
    int cursorY;
    int isSelected;
} GameState;

/* ================= Console ================= */

static HANDLE gH;

void initConsole(void) {
    gH = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO info = {100, FALSE};
    SetConsoleCursorInfo(gH, &info);
}

void color(int t, int f) {
    SetConsoleTextAttribute(gH, (WORD)(f * 16 + t));
}

void gotoligcol(int y, int x) {
    COORD c = {(SHORT)x, (SHORT)y};
    SetConsoleCursorPosition(gH, c);
}

void clearLineAt(int y, int x, int w) {
    gotoligcol(y, x);
    for (int i = 0; i < w; i++) putchar(' ');
}

/* ================= Temps ================= */

int tempsRestantSec(const GameState *e) {
    int ecoule = (int)difftime(time(NULL), e->startTime);
    int r = e->tempsTotalSec - ecoule;
    return (r < 0) ? 0 : r;
}

/* ================= Affichage ================= */

void afficherCadre(void) {
    system("cls");
    color(BLANC, NOIR);

    gotoligcol(0, 1);
    printf("|");
    for (int i = 0; i < NB_COL; i++) printf("-");
    printf("|");

    for (int i = 0; i < NB_LIG; i++) {
        gotoligcol(i + 1, 1);          printf("|");
        gotoligcol(i + 1, NB_COL + 2); printf("|");
    }

    gotoligcol(NB_LIG + 1, 1);
    printf("|");
    for (int i = 0; i < NB_COL; i++) printf("-");
    printf("|");

    color(BLANC, NOIR);
}

void afficherGrille(const GameState *e) {
    // 1 caractère par case => alignement parfait
    char sym[] = {'.','A','B','C','D','E'};
    int col[]  = {GRIS,ROUGE,VERT,BLEU,JAUNE,MAGENTA};

    for (int i = 0; i < NB_LIG; i++) {
        gotoligcol(i + 1, 2);
        for (int j = 0; j < NB_COL; j++) {
            int v = e->grille[i][j];
            if (v < 0 || v > NB_ITEMS) v = 0;

            int bg = NOIR, fg = col[v];
            if (i == e->cursorY && j == e->cursorX) {
                bg = e->isSelected ? ROUGE : GRIS;
                fg = BLANC;
            }

            color(fg, bg);
            putchar(sym[v]);
        }
    }
    color(BLANC, NOIR);
}

void afficherHUD(const GameState *e) {
    const int x = NB_COL + 6;
    const int y = 2;
    const int W = 70; // largeur d'effacement (évite résidus)

    int t = tempsRestantSec(e);

    // Ligne: Niveau
    clearLineAt(y, x, W);
    gotoligcol(y, x);
    printf("Niveau : %d", e->niveauActuel);

    // Ligne: Vies
    clearLineAt(y + 2, x, W);
    gotoligcol(y + 2, x);
    printf("Vies : ");
    color(ROUGE, NOIR);
    for (int i = 0; i < e->vies; i++) printf("<3 ");
    color(BLANC, NOIR);

    // Ligne: Score
    clearLineAt(y + 4, x, W);
    gotoligcol(y + 4, x);
    printf("Score : %d", e->score);

    // Ligne: Coups
    clearLineAt(y + 5, x, W);
    gotoligcol(y + 5, x);
    printf("Coups restants : %d", e->coupsRestants);

    // Ligne: Temps
    clearLineAt(y + 6, x, W);
    gotoligcol(y + 6, x);
    printf("Temps restant : %02d:%02d", t / 60, t % 60);

    // Contrat
    clearLineAt(y + 8, x, W);
    gotoligcol(y + 8, x);
    printf("Contrat (elimines / objectif / reste a eliminer) :");

    int l = y + 9;
    for (int i = 1; i <= NB_ITEMS; i++) {
        if (e->contrat[i] > 0) {
            int reste = e->contrat[i] - e->elimines[i];
            if (reste < 0) reste = 0;

            clearLineAt(l, x, W);
            gotoligcol(l, x);
            // ✅ partie manquante: affiche explicitement "reste à éliminer"
            printf("Item %d : %d / %d  (reste %d)", i, e->elimines[i], e->contrat[i], reste);
            l++;
        }
    }

    // Si le contrat a moins de lignes qu'avant, on nettoie quelques lignes “au cas où”
    for (int k = 0; k < 3; k++) {
        clearLineAt(l + k, x, W);
    }

    // Aide commandes
    clearLineAt(NB_LIG - 1, x, W);
    gotoligcol(NB_LIG - 1, x);
    color(GRIS, NOIR);
    printf("[ZQSD/Fleches] Deplacer | [ESPACE] Selection | [4] Quitter");
    color(BLANC, NOIR);
}

/* ================= Input ================= */

int lireTouche(void) {
    int c = _getch();
    if (c == 0 || c == 224) {
        int a = _getch();
        if (a == 72) return KEY_UP;
        if (a == 80) return KEY_DOWN;
        if (a == 75) return KEY_LEFT;
        if (a == 77) return KEY_RIGHT;
        return 0;
    }
    return c;
}

/* ================= Main (test affichage) ================= */

int main(void) {
    srand((unsigned)time(NULL));
    initConsole();

    GameState jeu = {0};
    jeu.niveauActuel = 1;
    jeu.vies = 3;
    jeu.score = 0;
    jeu.coupsRestants = 30;

    jeu.tempsTotalSec = 180;
    jeu.startTime = time(NULL);

    // Exemple contrat + progression (dans votre vrai jeu, c'est la logique qui remplit/maj ça)
    for (int i = 0; i <= NB_ITEMS; i++) {
        jeu.contrat[i] = 0;
        jeu.elimines[i] = 0;
    }
    jeu.contrat[1] = 20;
    jeu.contrat[3] = 10;

    // Remplissage grille de test
    for (int i = 0; i < NB_LIG; i++) {
        for (int j = 0; j < NB_COL; j++) {
            jeu.grille[i][j] = (rand() % NB_ITEMS) + 1;
        }
    }

    afficherCadre();

    while (1) {
        afficherGrille(&jeu);
        afficherHUD(&jeu);

        int t = lireTouche();
        if (t == '4') break;

        switch (t) {
            case 'z': case 'Z': case KEY_UP:
                if (jeu.cursorY > 0) jeu.cursorY--;
                break;

            case 's': case 'S': case KEY_DOWN:
                if (jeu.cursorY < NB_LIG - 1) jeu.cursorY++;
                break;

            case 'q': case 'Q': case KEY_LEFT:
                if (jeu.cursorX > 0) jeu.cursorX--;
                break;

            case 'd': case 'D': case KEY_RIGHT:
                if (jeu.cursorX < NB_COL - 1) jeu.cursorX++;
                break;

            case ' ':
                jeu.isSelected = !jeu.isSelected;
                break;

            default:
                break;
        }

        Sleep(10);
    }

    return 0;
}
